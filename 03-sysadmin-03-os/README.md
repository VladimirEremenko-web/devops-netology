### 1. Какой системный вызов делает команда cd?В прошлом ДЗ вы выяснили, что cd не является самостоятельной программой. Это shell builtin, поэтому запустить strace непосредственно на cd не получится. Вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае увидите полный список системных вызовов, которые делает сам bash при старте.Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.

`strace -o output.log /bin/bash -c 'cd /tmp' && egrep *tmp output.log`

`chdir("/tmp") = 0`

![Скриншот](/03-sysadmin-03-os/images/Screenshot_1.jpg)

### 2. Попробуйте использовать команду file на объекты разных типов в файловой системе. Например:

```vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64 
```

Используя strace, выясните, где находится база данных file, на основании которой она делает свои догадки.

Ответ:

`В man magic указано: The database of these “magic patterns” is usually located in a binary file in /usr/share/misc/magic.mgc or a directory of source text magic pattern fragment files in /usr/share/misc/magic. The database specifies what patterns are to be tested for, what message or MIME type to print if a particular pattern is found, and additional information to extract from the file.`

Выполним: `strace -o output.log /bin/bash -c 'file /bin/bash' && cat output.log | grep magic`

![Скриншот](/03-sysadmin-03-os/images/Screenshot_2.jpg)

Полагаю мы ищем: `openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`

### 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удалён (deleted в lsof), но сказать сигналом приложению переоткрыть файлы или просто перезапустить приложение возможности нет. Так как приложение продолжает писать в удалённый файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков, предложите способ обнуления открытого удалённого файла, чтобы освободить место на файловой системе.

Для достижения цели необходимо найти файловый дескриптор удаляемого файла и записать туда пустоту, например: `echo >/proc/2825/fd/4`

### 4. Занимают ли зомби-процессы ресурсы в ОС (CPU, RAM, IO)?

`Зомби-процессы не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов.`

### 5. В IO Visor BCC есть утилита opensnoop:

``` root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop /usr/sbin/opensnoop-bpfcc ```

На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04.

![Скриншот](/03-sysadmin-03-os/images/Screenshot_3.jpg)

### 6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc и где можно узнать версию ядра и релиз ОС.

Системный вызов `uname()`

Из man `Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.`

### 7. Чем отличается последовательность команд через ; и через && в bash? Например:

```
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
```

Есть ли смысл использовать в bash &&, если применить set -e?

`set -e установка или снятие значений параметров оболочки. Использование с && не имеет смысла, т.к. с -e произойдет немедленный выход, если команда завершается с ненулевым статусом.`

### 8. Из каких опций состоит режим bash set -euxo pipefail, и почему его хорошо было бы использовать в сценариях?

```
set -e прекращает выполнение скрипта, если команда завершилась ошибкой.
set -u - прекращает выполнение скрипта, если встретилась несуществующая переменная.
set -x - выводит выполняемые команды в stdout перед выполненинем.
set -o pipefail - прекращает выполнение скрипта, даже если одна из частей пайпа завершилась ошибкой. В этом случае bash-скрипт завершит выполнение, если mycommand вернёт ошибку, не смотря на true в конце пайплайна: mycommand | true.
```

### 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps изучите (/PROCESS STATE CODES), что значат дополнительные к основной заглавной букве статуса процессов. Его можно не учитывать при расчёте (считать S, Ss или Ssl равнозначными).

```
`Ss` - неактивные процессы;
`R+` - выполняющиеся в группе приоритетных.

Дополнительные к заглавной букве - это дополнительные значения состояния процесса:
`<` - высокий приоритет;
`N` - низкий приорит;
`L` - имеет страницы, заблокированные в памяти;
`s` - является лидером сеанса;
`l` - является многопоточным;
`+` - находится в группе приоритетных процессов.  
```